<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-05-16T13:46:46+09:00</updated><id>http://localhost:4000/</id><title type="html">B.I.T.W.O.R.K.S</title><subtitle>Embedded Bit Works</subtitle><author><name>Eddy Kim</name><email>eddykim72@outlook.com</email></author><entry><title type="html">Place Volatile Accurately</title><link href="http://localhost:4000/notes/2018/05/16/Place-volatile-accurately.html" rel="alternate" type="text/html" title="Place Volatile Accurately" /><published>2018-05-16T00:00:00+09:00</published><updated>2018-05-16T00:00:00+09:00</updated><id>http://localhost:4000/notes/2018/05/16/Place-volatile-accurately</id><content type="html" xml:base="http://localhost:4000/notes/2018/05/16/Place-volatile-accurately.html">&lt;p&gt;A volatile object is one whose value might change spontaneously. That is, when you declare an object to be volatile, you’re telling the compiler that the object might change state even though no statements in the program appear to change it.&lt;/p&gt;

&lt;p&gt;Compilers can optimize accesses to nonvolatile objects by reading an object’s value into a CPU register, working with that register for a while, and eventually writing the value in the register back to the object. Compilers aren’t permitted to do this sort of optimization with volatile objects. Every time the source program says to read from or write to a volatile object, the compiled code must do so.&lt;/p&gt;

&lt;p&gt;In my last column, I advised you to use the volatile qualifier, but use it judiciously.&lt;a href=&quot;http://www.embedded.com/electronics-blogs/programming-pointers/4025609/Place-volatile-accurately#endnotes&quot;&gt;1&lt;/a&gt; This month, I’ll  present some specific situations to show why and how you should think carefully about exactly where to place the &lt;strong&gt;volatile&lt;/strong&gt; keyword in declarations.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Modeling memory-mapped device registers&lt;/strong&gt; Many processors use memory-mapped I/O, which maps device registers to fixed addresses in the conventional memory space. To a C or C++ programmer, a memory-mapped device register looks very much like an ordinary data object.&lt;/p&gt;

&lt;p&gt;For the past year or so, I’ve been presenting examples of memory-mapped I/O using the ARM Evaluator-7T single-board computer. The board’s documentation refers to the device registers as &lt;em&gt;special registers&lt;/em&gt;. The memory is byte-addressable, but each register is a four-byte word aligned to an address that’s a multiple of four. You can manipulate each special register as if it were an &lt;strong&gt;unsigned int&lt;/strong&gt;, or if you prefer, a &lt;strong&gt;uint32_t&lt;/strong&gt;. (Fixed-size integer types such as &lt;strong&gt;int16_t&lt;/strong&gt; and &lt;strong&gt;uint32_t&lt;/strong&gt; are defined in the C99 header **&lt;stdint.h&gt;**.)[2](http://www.embedded.com/electronics-blogs/programming-pointers/4025609/Place-volatile-accurately#endnotes)&lt;/stdint.h&gt;&lt;/p&gt;

&lt;p&gt;I generally prefer to use a symbolic type whose name conveys the meaning of the type rather than its physical extent, such as:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;typedef uint32_t special_register;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This style works well on the Evaluator-7T. All of its special registers are of the same type, so you can get away with using only one typedef. On a machine with device registers of several different sizes, you might find yourself defining several such typedefs. In that case, many programmers prefer to stick with types such as &lt;strong&gt;uint8_t&lt;/strong&gt;, &lt;strong&gt;uint16_t&lt;/strong&gt;, and &lt;strong&gt;uint32_t&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Many devices interact through a small collection of device registers, rather than just one. For example, the Evaluator-7T has two UARTs, numbered 0 and 1. Each UART is controlled by six special registers. You can represent these registers as members of a struct defined as:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UART&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UART&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UART&lt;/span&gt; 
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
	&lt;span class=&quot;n&quot;&gt;special_register&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ULCON&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
	&lt;span class=&quot;n&quot;&gt;special_register&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UCON&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
	&lt;span class=&quot;n&quot;&gt;special_register&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;USTAT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
	&lt;span class=&quot;n&quot;&gt;special_register&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UTXBUF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
	&lt;span class=&quot;n&quot;&gt;special_register&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;URXBUF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
	&lt;span class=&quot;n&quot;&gt;special_register&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UBRDIV&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
	&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The typedef before the struct definition elevates the name &lt;strong&gt;UART&lt;/strong&gt; from a mere tag to a full-fledged type name.&lt;a href=&quot;http://www.embedded.com/electronics-blogs/programming-pointers/4025609/Place-volatile-accurately#endnotes&quot;&gt;3 &lt;/a&gt;In C++, I’d define this struct as a class with appropriate member functions. Whether &lt;strong&gt;UART&lt;/strong&gt; is a C struct or a C++ class doesn’t affect the following discussion.&lt;/p&gt;

&lt;p&gt;The special registers for UART 0 reside at address 0x03FFD000. A program can access these registers via a “pointer to &lt;strong&gt;UART&lt;/strong&gt;” whose value is that address. As I explained in an earlier column, you can define that pointer as a macro:&lt;a href=&quot;http://www.embedded.com/electronics-blogs/programming-pointers/4025609/Place-volatile-accurately#endnotes&quot;&gt;4&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#define UART0 ((UART *)0x03FFD000)
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;or as a constant object:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;UART&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UART0&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UART&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x03FFD000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In C++, you can use a reference instead of a pointer.&lt;a href=&quot;http://www.embedded.com/electronics-blogs/programming-pointers/4025609/Place-volatile-accurately#endnotes&quot;&gt;5&lt;/a&gt; Whether you use a pointer or reference doesn’t affect the following discussion, so I’ll just use a pointer.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Hey! What about volatile?&lt;/strong&gt; Thus far, I haven’t used the keyword &lt;strong&gt;volatile&lt;/strong&gt; in any of these declarations. The special registers that control a UART in the Evaluator-7T, like nearly all device registers everywhere, are volatile. As I explained in my previous column, if you don’t use volatile where needed, the compiler may optimize your source code too aggressively into object code that doesn’t work properly.&lt;/p&gt;

&lt;p&gt;One way to ensure that the compiler treats UART 0 as a volatile object is to place the keyword &lt;strong&gt;volatile&lt;/strong&gt; in the pointer declaration, as either:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#define UART0 ((UART volatile *) 0x03FFD000)
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;or as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;UART volatile *const UART0  = (UART *) 0x03FFD000;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you use the latter declaration (the constant pointer object), you could also write &lt;strong&gt;volatile&lt;/strong&gt; in the cast, as in:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;UART volatile *const UART0  = (UART volatile *)0x03FFD000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but it’s not necessary. For any type T, C and C++ provide a standard (built-in) conversion from “pointer to &lt;strong&gt;T&lt;/strong&gt;” to “pointer to &lt;strong&gt;volatile T&lt;/strong&gt;“, as well as a conversion from “pointer to &lt;strong&gt;T&lt;/strong&gt;” to “pointer to &lt;strong&gt;const T&lt;/strong&gt;“.&lt;/p&gt;

&lt;p&gt;Declaring an entire object to be volatile (and/or const) effectively declares each member of that object as volatile (and/or const).&lt;/p&gt;

&lt;p&gt;Adding the keyword &lt;strong&gt;volatile&lt;/strong&gt; to the declaration of &lt;strong&gt;UART0&lt;/strong&gt; will probably force you to add &lt;strong&gt;volatile&lt;/strong&gt; to other declarations in the program. For example, suppose that:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UART&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;is a function that transmits characters one at a time from the null-terminated character sequence starting at &lt;strong&gt;s&lt;/strong&gt; to the UART at &lt;strong&gt;u&lt;/strong&gt;. If &lt;strong&gt;UART0&lt;/strong&gt; is a “pointer to &lt;strong&gt;volatile UART&lt;/strong&gt;“, the call:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hello, world&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UART0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// error&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;won’t compile. The compiler will not convert a “pointer to &lt;strong&gt;volatile UART&lt;/strong&gt;” into “pointer to &lt;strong&gt;UART&lt;/strong&gt;“, unless you use a cast, as in:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hello, world&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UART&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UART0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// ouch!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The cast will allow the code to compile, but it won’t run properly because the put function will treat a volatile UART as if it were nonvolatile.&lt;/p&gt;

&lt;p&gt;Forget the cast. What you should do is add &lt;strong&gt;volatile&lt;/strong&gt; to the declaration of put’s second parameter, as in:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UART&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// yes!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Of course, adding &lt;strong&gt;volatile&lt;/strong&gt; here may force you to add &lt;strong&gt;volatile&lt;/strong&gt; elsewhere. Your compiler will be glad to point out where.&lt;strong&gt;Modeling registers accurately&lt;/strong&gt; A declaration such as:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;UART&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UART0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;has a subtle, but important, implication: that UART objects are not inherently volatile. That is, the declaration suggests that, while &lt;strong&gt;UART0&lt;/strong&gt; points to a volatile UART, some UARTs elsewhere in the system might not be volatile. This is good programming style only if it’s an accurate model of the hardware.&lt;/p&gt;

&lt;p&gt;On the other hand, if all UARTs are indeed volatile, as is the case on the Evaluator-7T, then the model is inaccurate, and you would do better to build the volatility into the UART type.An easy way to build in volatility into each UART is to write the typedef as:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UART&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UART&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;C and C++ let you write &lt;strong&gt;typedef&lt;/strong&gt;, &lt;strong&gt;struct UART&lt;/strong&gt;, and &lt;strong&gt;volatile&lt;/strong&gt; in any order. I suspect many programmers would prefer:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UART&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UART&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I recommend placing &lt;strong&gt;const&lt;/strong&gt; and &lt;strong&gt;volatile&lt;/strong&gt; to the right of the types they modify.&lt;/p&gt;

&lt;p&gt;Building volatility into the UART cleans up your code a bit. You no longer need to use &lt;strong&gt;volatile&lt;/strong&gt; in the declaration of the pointer to the memory-mapped UART. That is, the declaration for UART0 can revert to either:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#define UART0 ((UART *)0x03FFD000)
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;or:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;UART&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UART0&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UART&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x03FFD000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and the declaration of the put function can revert to:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UART&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is good.&lt;/p&gt;

&lt;p&gt;On the other hand, the declaration:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UART&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UART&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;leaves me feeling a bit queasy. It actually defines two different types: &lt;strong&gt;UART&lt;/strong&gt; as a volatile type and &lt;strong&gt;struct UART&lt;/strong&gt; as a nonvolatile type. I want to ensure that all UART objects are volatile, but this declaration makes it possible to declare something like:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UART&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UART0&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UART&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x03FFD000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and then access a UART as a nonvolatile object. I would think that’s a bug, not a feature.&lt;/p&gt;

&lt;p&gt;In fact, the typedef:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UART&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UART&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;compiles only in C, not in C++. C++ compilers complain (or should complain) that the typedef is an invalid redefinition of type UART. Yet another reason to prefer C++ over C.&lt;/p&gt;

&lt;p&gt;A better way to define UART as an inherently volatile type is to fold the entire struct definition into the typedef and eliminate the structure tag, as in:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* no tag */&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;special_register&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ULCON&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;special_register&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UCON&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
    &lt;span class=&quot;c1&quot;&gt;// etc. &lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UART&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Alternatively, you can declare every member of the struct to be volatile, as in: typedef struct UART UART;&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UART&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;special_register&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ULCON&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;special_register&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UCON&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
    &lt;span class=&quot;c1&quot;&gt;// etc. &lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here we are again.&lt;/p&gt;

&lt;p&gt;If the &lt;strong&gt;special_register&lt;/strong&gt; type is not inherently volatile, that implies that some special registers might not be volatile. In the Evaluator-7T, as in every other machine I’ve seen, all the memory-mapped device registers should be declared volatile. The most obvious way to do that is define &lt;strong&gt;special_register&lt;/strong&gt; as a volatile type, as in:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;special_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is the style I’ve used in previous articles, and it’s the style I recommend.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Me and my shadow&lt;/strong&gt; Under what circumstances would you leave volatility out of your device register type(s)? Some machines have some device registers that don’t like to be read. If you need to keep track of the value you last wrote to such a register, you must maintain a “shadow” copy of the register’s value stored in RAM. For clarity, the type of the shadow should be the same as the type of its corresponding device register. However, the shadow need not be declared &lt;strong&gt;volatile&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;When dealing with a shadow register, you have a few stylistics choices. The simplest approach is to use the exact same type–a volatile type–for both the shadow and the device registers. The only downside to this approach is that the compiler may generate less than optimal code for accessing the shadow register. I suspect the impact will be negligible in most cases.&lt;/p&gt;

&lt;p&gt;I recommend defining a nonvolatile type for the shadow register and a volatile version of the shadow register type for the corresponding device register, as in:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shadow_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shadow_register&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;special_register&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Works for me.&lt;/p&gt;

&lt;p&gt;Thanks to Andrew Sloss at ARM for help with this article.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;*Dan Saks&lt;/strong&gt; is president of Saks &amp;amp; Associates, a C/C++ training and consulting company. For more information about Dan Saks, visit his website at www.dansaks.com. Dan also welcomes your feedback: e-mail him at dsaks@wittenberg.edu.*&lt;/p&gt;</content><author><name>Eddy Kim</name><email>eddykim72@outlook.com</email></author><category term="C" /><category term="volatile" /><summary type="html">A volatile object is one whose value might change spontaneously. That is, when you declare an object to be volatile, you’re telling the compiler that the object might change state even though no statements in the program appear to change it.</summary></entry><entry><title type="html">How to Use C’s volatile Keyword</title><link href="http://localhost:4000/notes/2018/05/15/C-volatile-keyword.html" rel="alternate" type="text/html" title="How to Use C's volatile Keyword" /><published>2018-05-15T00:00:00+09:00</published><updated>2018-05-15T00:00:00+09:00</updated><id>http://localhost:4000/notes/2018/05/15/C-volatile-keyword</id><content type="html" xml:base="http://localhost:4000/notes/2018/05/15/C-volatile-keyword.html">&lt;p&gt;Wed, 2007-11-07 21:07 – webmasterby &lt;a href=&quot;http://www.embeddedgurus.net/stack-overflow&quot;&gt;Nigel Jones&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The proper use of C’s volatile keyword is poorly understood by many programmers. This is not surprising, as most C texts dismiss it in a sentence or two. This article will teach you the proper way to do it.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Have you experienced any of the following in your C or C++ embedded code?&lt;/li&gt;
  &lt;li&gt;Code that works fine–until you enable compiler optimizations&lt;/li&gt;
  &lt;li&gt;Code that works fine–until interrupts are enabled&lt;/li&gt;
  &lt;li&gt;Flaky hardware drivers&lt;/li&gt;
  &lt;li&gt;RTOS tasks that work fine in isolation–until some other task is spawned&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you answered yes to any of the above, it’s likely that you didn’t use the C keyword volatile. You aren’t alone. The use of volatile is poorly understood by many programmers. Unfortunately, most books about the C programming language dismiss volatile in a sentence or two.&lt;/p&gt;

&lt;p&gt;C’s volatile keyword is a qualifier that is applied to a variable when it is declared. It tells the compiler that the value of the variable may change at any time–without any action being taken by the code the compiler finds nearby. The implications of this are quite serious. However, before we examine them, let’s take a look at the syntax.&lt;/p&gt;

&lt;h2 id=&quot;volatile-keyword-syntax&quot;&gt;volatile keyword syntax&lt;/h2&gt;

&lt;p&gt;To declare a variable volatile, include the keyword volatile before or after the data type in the variable definition. For instance both of these declarations will declare foo to be a volatile integer:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;volatile int foo;
int volatile foo;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now, it turns out that pointers to volatile variables are very common, especially with memory-mapped I/O registers. Both of these declarations declare pReg to be a pointer to a volatile unsigned 8-bit integer:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;volatile uint8_t * pReg;  uint8_t volatile * pReg;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Volatile pointers to non-volatile data are very rare (I think I’ve used them once), but I’d better go ahead and give you the syntax:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;int * volatile p;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;And just for completeness, if you really must have a volatile pointer to a volatile variable, you’d write:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;int volatile * volatile p;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Incidentally, for a great explanation of why you have a choice of where to place volatile and why you should place it after the data type (for example, int volatile * foo), read Dan Sak’s column “Top-Level cv-Qualifiers in Function Parameters” (Embedded Systems Programming, February 2000, p. 63).&lt;/p&gt;

&lt;p&gt;Finally, if you apply volatile to a struct or union, the entire contents of the struct/union are volatile. If you don’t want this behavior, you can apply the volatile qualifier to the individual members of the struct/union.&lt;/p&gt;

&lt;h2 id=&quot;proper-use-of-volatile&quot;&gt;Proper use of volatile&lt;/h2&gt;

&lt;p&gt;A variable should be declared volatile whenever its value could change unexpectedly. In practice, only three types of variables could change:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Memory-mapped peripheral registers&lt;/li&gt;
  &lt;li&gt;Global variables modified by an interrupt service routine&lt;/li&gt;
  &lt;li&gt;Global variables accessed by multiple tasks within a multi-threaded application&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We’ll talk about each of these cases in the sections that follow.&lt;/p&gt;

&lt;h3 id=&quot;peripheral-registers&quot;&gt;Peripheral registers&lt;/h3&gt;

&lt;p&gt;Embedded systems contain real hardware, usually with sophisticated peripherals. These peripherals contain registers whose values may change asynchronously to the program flow. As a very simple example, consider an 8-bit status register that is memory mapped at address 0×1234. It is required that you poll the status register until it becomes non-zero. The naive and incorrect implementation is as follows:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;uint8_t * pReg = (uint8_t *) 0x1234; 
// Wait for register to become non-zero
while (*pReg == 0) { } // Do something else
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This will almost certainly fail as soon as you turn compiler optimization on, since the compiler will generate assembly language that looks something like this:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;  mov ptr, #0x1234 &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mov a, @ptr &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;loop: &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;​	&lt;code class=&quot;highlighter-rouge&quot;&gt;bz loop&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The rationale of the optimizer is quite simple: having already read the variable’s value into the accumulator (on the second line of assembly), there is no need to reread it, since the value will always be the same. Thus, in the third line, we end up with an infinite loop. To force the compiler to do what we want, we modify the declaration to:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;uint8_t volatile * pReg = (uint8_t volatile *) 0x1234;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The assembly language now looks like this:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;  mov ptr, #0x1234 loop: mov a, @ptr bz loop&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The desired behavior is achieved.&lt;/p&gt;

&lt;p&gt;Subtler problems tend to arise with registers that have special properties. For instance, a lot of peripherals contain registers that are cleared simply by reading them. Extra (or fewer) reads than you are intending can cause quite unexpected results in these cases.Interrupt service routinesInterrupt service routines often set variables that are tested in mainline code. For example, a serial port interrupt may test each received character to see if it is an ETX character (presumably signifying the end of a message). If the character is an ETX, the ISR might set a global flag. An incorrect implementation of this might be:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;int etx_rcvd = FALSE; void main()  { ...  while (!ext_rcvd)  { // Wait }  ... } interrupt void rx_isr(void)  { ...  if (ETX == rx_char)  { etx_rcvd = TRUE; }  ... }&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;With compiler optimization turned off, this code might work. However, any half decent optimizer will “break” the code. The problem is that the compiler has no idea that etx_rcvd can be changed within an ISR. As far as the compiler is concerned, the expression !ext_rcvd is always true, and, therefore, you can never exit the while loop. Consequently, all the code after the while loop may simply be removed by the optimizer. If you are lucky, your compiler will warn you about this. If you are unlucky (or you haven’t yet learned to take compiler warnings seriously), your code will fail miserably. Naturally, the blame will be placed on a “lousy optimizer.”&lt;/p&gt;

&lt;p&gt;The solution is to declare the variable etx_rcvd to be volatile. Then all of your problems (well, some of them anyway) will disappear.&lt;/p&gt;

&lt;h3 id=&quot;multi-threaded-applications&quot;&gt;Multi-threaded applications&lt;/h3&gt;

&lt;p&gt;Despite the presence of queues, pipes, and other scheduler-aware communications mechanisms in real-time operating systems, it is still fairly common for two tasks to exchange information via a shared memory location (that is, a global). Even as you add a preemptive scheduler to your code, your compiler has no idea what a context switch is or when one might occur. Thus, another task modifying a shared global is conceptually identical to the problem of interrupt service routines discussed previously. So all shared global variables should be declared volatile. For example, this is asking for trouble:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;int cntr; void task1(void)  { cntr = 0;  while (cntr == 0)  { sleep(1); }  ... } void task2(void)  { ... cntr++;  sleep(10);  ... }&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This code will likely fail once the compiler’s optimizer is enabled. Declaring cntr to be volatile is the proper way to solve the problem.&lt;/p&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final thoughts&lt;/h2&gt;

&lt;p&gt;Some compilers allow you to implicitly declare all variables as volatile. Resist this temptation, since it is essentially a substitute for thought. It also leads to potentially less efficient code.&lt;/p&gt;

&lt;p&gt;Also, resist the temptation to blame the optimizer or turn it off. Modern optimizers are so good that I cannot remember the last time I came across an optimization bug. In contrast, I come across failures by programmers to use volatile with depressing frequency.&lt;/p&gt;

&lt;p&gt;If you are given a piece of flaky code to “fix,” perform a grep for volatile. If grep comes up empty, the examples given here are probably good places to start looking for problems.This article was published in the July 2001 issue of &lt;a href=&quot;http://www.embedded.com/mag.htm&quot;&gt;Embedded Systems Programming&lt;/a&gt;. If you wish to cite the article in your own work, you may find the following MLA-style information helpful:Jones, Nigel. “Introduction to the Volatile Keyword” Embedded Systems Programming, July 2001&lt;/p&gt;</content><author><name>Eddy Kim</name><email>eddykim72@outlook.com</email></author><category term="C" /><category term="volatile" /><summary type="html">Wed, 2007-11-07 21:07 – webmasterby Nigel Jones</summary></entry></feed>